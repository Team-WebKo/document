# 동기화 로직 상세 설계
---
## 스케줄링 방식
+ 시간을 기반으로 정해진 작업을 자동으로 실행한다

### Spring Boot 스케줄링
```java
@Scheduled(cron = "0 0 3 * * *") // 매일 새벽 3시
public void syncTourData() {
    // TourAPI 호출 → DB 저장 로직
}
```
+ `cron`표현식으로 지정 - [cron이란?](#cron이란?)
+ 실행 주기 : 일, 시간, 분 단뒤 등 설정 가능

### 왜 필요한가?
+ 동기화의 자동화로 추가적 작업이 줄어든다
+ 관리자의 실수 방지

### 보완
+ 정해진 규칙에 대해서 실행한다
  + 추가적인 작업이 발생 할 수 있다 - 수동 요청도 가능하도록 설계

---

## 동기화를 언제 진행하는 것이 좋은가?
+ 사용자 트래픽이 적은 시간대를 예상 및 실제 사용량에 따라 조정
+ Tour API의 변경 주기가 있다면 일정 시간 간격을 두고 작업하는것도 가능?
+ push?

---

## 트랜잭션 중단 시 처리 방법
+ 문제 예시
  + 1 ~ 100 페이지 중 50페이지 저장 중 예외 발생 > 나머지 데이터 처리 방법

### 해결 전략
| 전략 | 설명 |
| --- | --- |
| 페이지 기반 전략 | pageNo 단위로 저장<br>-> 실패한 pageNo만 재시도 |
| 중간 로그 저장 | 마지막 성공 pageNo 기록<br>-> 실패 시 이어서 진행 |
| 배치 트랜잭션 관리 | 페이지 단위로 트랜잭션 처리<br>-> 전체 실패 방지 |

---

## 서브 프로젝트 기준 및 이점
### 서브 프로젝트란?
+ Gradle에서 하나의 프로젝트를 여러 모듈로 분리하는 것
+ 각 모듈은 `:common`, `:api-client`, `:place-service`등으로 나눌 수 있다

### 나누는 이유는?
1. 책임 분리
   + API 호출 로직은 `:api-client`
   + 비즈니스 로직은 `:place-service`
2. 재사용성
   + 다른 서비스에서 동일 API를 활용할 경우, 모듈만 재사용 하면 된다
3. 테스트 용이성
   + 기능별로 단위 테스트 작성이 쉽다
4. 배포 유연성
   + 서브 모듈만 독립 배포 가능

### 도입 기준?
+ 공통 로직인가?
+ 독립적으로 개발 및 배포가 가능한가?
+ 기능 간 의존성이 얼마나 되는가?(높지는 않은가?)

---

## 시스템 전체 흐름


---

## 정리
+ 관리자 요청 또는 스케줄러에 의해 동기화 시작
+ TourAPI에서 JSON으로 데이터 받아온다
+ DTO로 변환 > Entity 매핑 > DB 저장
+ 사용자 요청 시 Query 모델을 통해 DB에서 조회한다 (동기화 적용 시)
  + 동기화 미 적용 시 : 데일리 여행지로 사용자별로 쿼리 발생

---

## 추가 내용
### cron이란?
| 위치 | 의미 | 예시 값 |
| --- | --- | --- |
| 1 | 초 (0~59) | 0 |
| 2 | 분 (0~59) | 0 |
| 3 | 시 (0~23) | 0 |
| 4 | 일 (1~31) | 0 |
| 5 | 월 (1~12) | 0 |
| 6 | 요일 (0~6) | 0 |

+ 예시

| cron 표현식 | 의미 |
|----------|----|
| `0 0 3 * * *` | 매일 03:00 |
| `0 */10 * * * *` | 10분마다 |
| `0 0 1 * * MON` | 매주 월요일 01:30 |
| `0 0 3 1 * *` | 매월 1일 03:00 |